import math
import numpy as np
import pandas as pd

# author: Kevin Masters
# email: kmmasters@tamu.edu
# This script uses electric field data to calculate the induced voltage on transmission lines
# The induced voltages is calculated using transmission line and substation data
# The script then uses this induced voltage data and transformer data to calculate GIC using a DC model
# The GIC data for the transmission lines and transformers is then outputted as a csv file

# Critical data for gic calculation:
# 1. Electric field: magnitude, direction
# 2. Substation data: latitude, longitude, grounding resistance
# 3. Transmission line data: from bus, to bus, voltage (Kv-LL), Length, Resistance
# 4. Transformer data: Type (GSU, GY-GY-D, GY-GY, auto), Winding resistance (HV and LV), Bus info for end and finish

# Solve for input voltage on transmission line
# V = EnLn + EeLe; En = Northward E, Ee = Eastward E, Ln = Northward length, Le = eastward length
# need to know formatting of data, put into an array using numpy

# Ln = (111.133 - 0.56cos(2*phi))*(delta_latitude)
# delta_lat = difference between latitudes (to bus - from bus)
# phi = (LatA + LatB) / 2
# convert phi to radians using math
# Le = (111.5065 - 0.1872cos(2*phi))*cos(phi)*delta_long
# delta_long = difference between longitudes (to bus - from bus)

# need to create admittance matrix
# nodal analysis with dc models
# I_dc = V(n,m) / R_eff , (V(n,m) is from line connecting bus m to n)
# G = network conductance matrix
# V = (G^-1)*I_dc


# creating a function to put pertinent data from csv files into arrays which are used for the calculations
# this data will come from the application core after integration
def csv_to_array(filename):

    df = pd.read_csv(filename)
    # reading in the csv file using pandas
    # putting this into a dataframe

    array = df.to_numpy()
    # converting the dataframe to a numpy array

    # returning the numpy array
    return array



def grab_line_cords(lines, subs):

    # function to cross-ref line data w/ sub data to get lats and longs of line buses

    line_data = np.zeros((np.shape(lines)[0], 5))
    # creating a new array that will be useful for calculating the input voltage/line voltage
    # this array will have the same number of rows as the array generated by the csv file
    # format of array: line number, from bus longitude, from bus latitude, to bus longitude, to bus latitude

    long_from = 0
    # variable to hold from bus longitude

    lat_from = 0
    # variable to hold from bus latitude

    long_to = 0
    # variable to hold to bus longitude

    lat_to = 0
    # variable to hold to bus latitude

    # using a nested for loop to populate line_data array with necessary information for calculating input voltages
    # the nested for loop cycles through the line_array data and the substation_array data
    # looking for where my from bus and to bus locations are
    # for loops will go row by row through the arrays

    for i in range(np.shape(lines)[0]):
        for j in range(np.shape(subs)[0]):
            # if statement that checks if the substation high bus or low bus is equal to the line from bus
            if subs[j][4] == lines[i][1] or subs[j][5] == lines[i][1]:
                # if there's a bus number match, then the from longitude and latitude are set
                long_from = subs[j][2]
                # setting the from longitude equal to the matching substation longitude
                lat_from = subs[j][1]
                # setting the from latitude equal to the matching substation latitude
            if subs[j][4] == lines[i][2] or subs[j][5] == lines[i][2]:
                # this if statement functions in the same way, except now it's looking for the to bus
                long_to = subs[j][2]
                # setting the to longitude equal to the matching substation longitude
                lat_to = subs[j][1]
                # setting the to latitude equal to the matching substation latitude

        # now that data has been pulled for the longitudes and latitudes, will populate the
        # line data array with this information

        line_data[i][0] = lines[i][0]
        # setting the line number equal to the line number tested by the nested for loop
        # the next four statements basically populate the array in the format described previously
        line_data[i][1] = long_from
        line_data[i][2] = lat_from
        line_data[i][3] = long_to
        line_data[i][4] = lat_to

    return line_data


def length_calculator(linecords):
    LN = 0
    # variable to hold North-South distance
    # will be multiplied by northward electric field (V/km)
    LE = 0
    # variable to hold the East-West distance
    # will be multiplied by eastward electric field (V/km)

    phi = 0
    # variable necessary for calculating LE and LN
    # defined as the average of the two latitudes

    delta_lat = 0
    # variable necessary for calculating LN
    # this is the difference between the to bus latitude and the from bus latitude

    delta_long = 0
    # variable necessary for calculating LE
    # this is the difference between the to bus longitude and the from bus longitude

    length_array = np.zeros((np.shape(linecords)[0], 4))
    # array to hold the variables needed to calculate the North-South distance and East-West distance
    # format: line number, phi, delta_lat, delta_long
    # these distances are key for finding input voltage
    # input voltage = EN*LN + EE*LE
    # EN and EE are the electric field in the northward and eastward direction respectively (V/km)

    # using a for loop to cycle through the line data array
    # will use the information gathered to populate the length array
    for i in range(np.shape(linecords)[0]):
        phi = (linecords[i][2] + linecords[i][4]) / 2
        # phi = (lat_from + lat_to) / 2
        phi = math.radians(phi)
        # converting from degrees to radians
        # conversion is necessary for cosine function in python
        delta_lat = linecords[i][4] - linecords[i][2]
        # delta_lat = lat_to - lat_from
        delta_long = linecords[i][3] - linecords[i][1]
        # delta_long = long_to - long_from

        # populating my length array with the calculated variables
        length_array[i][0] = linecords[i][0]
        # setting the line number to be the same
        length_array[i][1] = phi
        length_array[i][2] = delta_lat
        length_array[i][3] = delta_long
        # three statements above are filling in rows of the length array according to format defined previously
    return length_array



def iv_calculator(field, length):
    # this function calculates the induced voltage on a line
    Input_Voltages = np.zeros((np.shape(field)[0], np.shape(length)[0], 2))
    # creating an array that will hold the calculated values for the input voltage
    # created as a 3d array to handle time component that will be present from Stephen's E-Field calculator
    # format of array: [time] line number, voltage

    voltage = 0
    # variable to hold the calculated voltage for each line

    # using a nested for loop to calculate LN, LE, and then the line voltage based upon E field
    for t in range(np.shape(field)[0]):
        # loop over time dimension
        for i in range(np.shape(field)[1]):
            # first for loop cycles through E field data
            for j in range(np.shape(length)[0]):
                # this for loop is cycling through all of the different lines
                LN = (111.133 - (0.56 * math.cos(2 * length[j][1]))) * length[j][2]
                # LN being calculated based upon formula in test case research paper
                # the phi and delta_lat values used are specific to the line being considered
                LE = (111.5065 - (0.1872 * math.cos(2 * length[j][1]))) * math.cos(length[j][1]) * \
                     length[j][
                         3]
                # LE being calculated based upon formula in test case research paper
                # the phi and delta_long values used are specific to the line being considered
                voltage = (LN * field[t][i][1]) + (LE * field[t][i][0])
                # calculating the input voltage for the line being considered, e.g. line 1, 2, etc.
                # formula used is: V = LN*EN + LE*EE
                voltage = round(voltage, 2)
                # rounding the calculated voltage to two decimal places
                # this is for ease of viewing and to align with values presented in test case

                Input_Voltages[t][j][0] = length[j][0]
                # storing the line number
                Input_Voltages[t][j][1] = voltage
                # storing the voltage calculated for that line number

                # nested for loop will continue until voltage for all lines has been calculated
    # returning array
    return Input_Voltages



# creating a function to calculate the norton equivalent current from the induced voltage
def equivalent_current(iv_data, line_info):
    ic_data = np.zeros((np.shape(iv_data)[0], 4))
    # format: line number, equivalent current, from bus, to bus
    for i in range(np.shape(iv_data)[0]):
        current = (-3*(iv_data[i][1])) / (line_info[i][5] + (1e6 * line_info[i][6]))
        # -3 comes from sign convention and that resistance is per phase
        # series blocking capacitance is modeled as a 1M ohm resistance
        # info on whether a blocking cap is present is in column 6 of line_info
        # only line 8 contains one in twenty bus case
        ic_data[i][0] = line_info[i][0]
        # storing line number
        ic_data[i][1] = current
        # storing the current
        ic_data[i][2] = line_info[i][1]
        ic_data[i][3] = line_info[i][2]
        # two lines above store the from bus and to bus info
    # returning new array
    return ic_data

def find_nodes(lineinfo):
    # Initializing set to store unique numbers
    node_nums = set()

    # Looping through array and checking for unique numbers
    for row in lineinfo:
        for num in row[1:3]:
            if num not in node_nums:
                # if the number isn't in there already, add it to the set
                node_nums.add(num)

    # Converting set to list and sorting in ascending order
    node_nums = sorted(list(node_nums))

    # Creating 2d array with node labels and values
    # these values correspond to bus numbers
    # this method works for the 6 bus case
    # method must be refined for 20 bus case
    # GY-GY transformer presenting issues
    # must find a way to account for the neutral at substations which have a GY-GY transformer
    # conductance matrix and further calculations incorrect if unable to account for these neutrals
    nodes = []
    for i, num in enumerate(node_nums):
        # adding in the values to 2d array
        nodes.append([f"node{i + 1}", num])
    # returning array
    return nodes


def current_injection_vector_generator(nodes, calculated_current):
    # this function is used to generate the injected current vector/matrix
    injection_vector = np.zeros((np.shape(nodes)[0], 1))

    for i in range(np.shape(nodes)[0]):
        # looping through the nodes
        for j in range(np.shape(calculated_current)[0]):
            # looping through calculated current array, which contains line data
            if nodes[i][1] == calculated_current[j][2]:
                # if the node matches with the from bus of the line, then it gets the negative of the current
                injection_vector[i][0] = injection_vector[i][0] + (-1 * calculated_current[j][1])
            if nodes[i][1] == calculated_current[j][3]:
                # if the node matches with the to bus of the line, then it gets the positive of the current
                injection_vector[i][0] = injection_vector[i][0] + calculated_current[j][1]

    # returning array/vector
    return injection_vector


def compare_arrays(array1, array2):
    # function to compare two arrays
    # for validation purposes only
    # the arrays are assumed to be of the same shape
    # safe assumption since this is a validation function
    for i in range(np.shape(array1)[0]):
        for j in range(np.shape(array1)[1]):
            if abs(array1[i][j] - array2[i][j]) > 0.01 * abs(array1[i][j]):
                return False
    return True



def conductance_matrix_node_relation_generator(nodes, lines, transformers, substations, current):
    # function to generate the conductance matrix for the DC model
    # this function is critical to finding the nodal voltages
    # these nodal voltages are needed to find the current in the transformer
    # this function also generates the information needed to compute the current once the nodal voltages are found
    # function must be expanded to account for parallel transformers like in 20 bus case
    # p variable holds the number of nodes in DC model
    p = np.shape(nodes)[0]

    # creating an nxn array to hold the conductance values
    conductance_matrix = np.zeros((p, p))

    # creating an array to hold the data necessary for calculating the line currents
    line_relation = np.zeros((np.shape(lines)[0], 5))
    # format of array: line number, node 1, node 2, norton equiv current, conductivity

    for j in range(np.shape(lines)[0]):
        # for loop used to find what nodes a line connects to
        # that information is then used to properly add conductances to the matrix
        # must also account to adding negative to the off diagonal
        match = 0
        # these variables are used for the off diagonals
        first_match = 0
        second_match = 0
        for i in range(np.shape(nodes)[0]):
            if nodes[i][1] == lines[j][1] or nodes[i][1] == lines[j][2]:
                # looking for matches
                match += 1
                if match == 1:
                    first_match = i
                if match == 2:
                    second_match = i
                # adding the conductance to the node its connected to
                conductance_matrix[i][i] += (3 / lines[j][5])
        # storing line relation info for calculating GIC in transmission lines
        # storing line number
        line_relation[j][0] = lines[j][0]
        # storing index of nodes its connected to
        line_relation[j][1] = first_match
        line_relation[j][2] = second_match
        # storing the norton equivalent current
        line_relation[j][3] = current[j][1]
        # storing the conductance
        line_relation[j][4] = (3 / lines[j][5])
        # putting the negative of the conductance into the off diagonal
        conductance_matrix[first_match][second_match] -= (3 / lines[j][5])
        conductance_matrix[second_match][first_match] -= (3 / lines[j][5])

    # creating a list that will store the index of the gsu transformers
    gsu_found = []

    for i in range(np.shape(transformers)[0]):
        # looping through the transformer data
        if transformers[i][1].lower() == 'gsu':
            # if a gsu is found, index is added to gsu_found list
            gsu_found.append(i)

    # same idea here, but for the auto transformers
    auto_found = []

    for i in range(np.shape(transformers)[0]):
        if transformers[i][1].lower() == 'auto':
            auto_found.append(i)

    # must account for the GY-GY and GY-GY-D with 20 bus case
    # treat a GY-GY-D the same as GY-GY

    # creating an array that holds information necessary for finding the current
    relation_array = np.zeros(((len(gsu_found) + 2 * len(auto_found)), 5), dtype='object')
    # format: transformer name, transformer type, first node, second node, conductance

    # variable used for indexing
    t_found_count = 0

    for i in range(len(gsu_found)):
        # looping through the gsu transformers
        # these are accounted into the conductance matrix differently than an auto
        for j in range(np.shape(nodes)[0]):
            # creating variables whose values will be determined by next for loop
            ground_res = 0
            conductance = 0
            for k in range(np.shape(substations)[0]):
                if (transformers[gsu_found[i]][3] == nodes[j][1] and nodes[j][1] ==
                    substations[k][4]) or (
                        transformers[gsu_found[i]][3] == nodes[j][1] and nodes[j][1] ==
                        substations[k][5]):
                    # checking to see if the node matches up with the bus info
                    ground_res = substations[k][3]
                    # setting the ground resistance equal to the matched substation's resistance
                    if transformers[gsu_found[i]][6] == 1:
                        # checking for a GIC blocking device
                        # a GIC bd will essentially make the conductance zero
                        # treated as a 1M ohm resistance in series with gsu resistance and grounding resistance
                        conductance = 1 / ((transformers[gsu_found[i]][2] / 3) + 1e6 + ground_res)
                    else:
                        # if no GIC bd, conductance is this value
                        # this doesn't account for parallel transformers
                        # must expand in future to account for this
                        conductance = (3 / (transformers[gsu_found[i]][2] + (3 * ground_res)))
                    # adding the calculated conductance to the conductance matrix
                    conductance_matrix[j][j] += conductance
                    # setting the info needed for the relationships derived from circuit
                    relation_array[t_found_count][0] = transformers[gsu_found[i]][0]
                    relation_array[t_found_count][1] = transformers[gsu_found[i]][1]
                    relation_array[t_found_count][2] = j
                    relation_array[t_found_count][3] = 'none'
                    relation_array[t_found_count][4] = conductance
                    # incrementing the count
                    t_found_count += 1

    for j in range(len(auto_found)):
        # the series from the auto works similarly to a line in the conductance matrix
        # similar matching procedure here
        match = 0
        first_match = 0
        second_match = 0
        for i in range(np.shape(nodes)[0]):
            if nodes[i][1] == transformers[auto_found[j]][3] or nodes[i][1] == \
                    transformers[auto_found[j]][5]:
                # checking for node matches
                match += 1
                if match == 1:
                    first_match = i
                if match == 2:
                    second_match = i
                # adding to conductance matrix
                conductance_matrix[i][i] += (3 / transformers[auto_found[j]][2])
                # this value coms from the W1 resistance, W1 corresponds to the series from the auto
        # putting negative of conductance into off diagonal
        conductance_matrix[first_match][second_match] -= (3 / transformers[auto_found[j]][2])
        conductance_matrix[second_match][first_match] -= (3 / transformers[auto_found[j]][2])
        # setting relationship info
        relation_array[t_found_count][0] = transformers[auto_found[j]][0]
        relation_array[t_found_count][1] = 'Auto, series'
        relation_array[t_found_count][2] = first_match
        relation_array[t_found_count][3] = second_match
        relation_array[t_found_count][4] = (3 / transformers[auto_found[j]][2])
        # incrementing count
        t_found_count += 1

    for i in range(len(auto_found)):
        # this next part of the code is for the auto common
        # the auto common behaves similarly to the gsu
        for j in range(np.shape(six_bus_nodes)[0]):
            ground_res = 0
            for k in range(np.shape(six_bus_sub_array)[0]):
                if (transformers[auto_found[i]][5] == nodes[j][1] and nodes[j][1] ==
                    substations[k][4]) or (
                        transformers[auto_found[i]][5] == nodes[j][1] and nodes[j][1] ==
                        substations[k][5]):
                    ground_res = substations[k][3]
                    # using the W2 resistance
                    # same way of calculating conductance here
                    # in DC model, common of auto is in series with resistance of substation
                    # adding conductance into conductance matrix
                    conductance_matrix[j][j] += (3 / (transformers[auto_found[i]][4] + (3 * ground_res)))
                    # setting relationship info for the auto common
                    relation_array[t_found_count][0] = transformers[auto_found[i]][0]
                    relation_array[t_found_count][1] = 'Auto, common'
                    relation_array[t_found_count][2] = j
                    relation_array[t_found_count][3] = 'none'
                    relation_array[t_found_count][4] = (3 / (transformers[auto_found[i]][4] + (3 * ground_res)))
                    # incrementing transformer counter
                    t_found_count += 1
    # returning both arrays
    return conductance_matrix, relation_array, line_relation



def node_voltage_calculator(cond_mat, i_inject):
    # this function uses matrix multiplication to find the nodal voltages
    # taking the inverse of the conductance matrix
    inv_cond_mat = np.linalg.inv(cond_mat)

    node_volt_mat = np.matmul(inv_cond_mat, i_inject)
    for i in range(np.shape(node_volt_mat)[0]):
        node_volt_mat[i][0] = round(node_volt_mat[i][0].item(), 2)
    # returning array
    return node_volt_mat



def transformer_current_calculator(relationship, nodalvolts):
    # function to calculate the current in transformer
    # mirroring the six bus test case example and producing result in amps
    # 20 bus case uses amps/phase
    # simple conversion, just divide amps by 3
    transformer_current_array = np.zeros((np.shape(relationship)[0], 3), dtype='object')
    # format of array: Transformer name, transformer type, current (A)

    for i in range(np.shape(relationship)[0]):
        # looping through the relationship array that holds info necessary to calculate current
        # creating variables that will be used in calculation
        node_volts = 0
        t_conduct = 0
        # populating first two columns with transformer name and transformer type
        transformer_current_array[i][0] = relationship[i][0]
        transformer_current_array[i][1] = relationship[i][1]
        if relationship[i][1].lower() == 'gsu':
            # checking if it's a gsu transformer
            node_volts = nodalvolts[six_b_relation_array[i][2]]
            # setting the voltage equal to the voltage of the node the transformer is connected to
            t_conduct = relationship[i][4]
            # pulling conductance info from relationship array
            # this info was stored in the function that generates the array
            transformer_current_array[i][2] = round((node_volts * t_conduct).item(), 2)
            # rounding value to match test case
        if relationship[i][1].lower() == 'auto, series':
            # checking if it's the auto series
            node_volts = (nodalvolts[relationship[i][2]] - nodalvolts[relationship[i][3]])
            # setting the node volts equal to the difference between the nodes the series part is connected to
            t_conduct = relationship[i][4]
            # pulling previously stored conductance information
            transformer_current_array[i][2] = round((node_volts * t_conduct).item(), 2)
            # storing calculated current
        if relationship[i][1].lower() == 'auto, common':
            # checking if it's the auto common
            # same procedure here as the gsu
            node_volts = nodalvolts[relationship[i][2]]
            t_conduct = relationship[i][4]
            transformer_current_array[i][2] = round((node_volts * t_conduct).item(), 2)
    # returning array with transformer current info
    return transformer_current_array



def line_GIC_calculator(linerelation, nodalvolts):
    # this function calculates the gic in the transmission lines
    # creating an array to hold the line gic data
    line_gic = np.zeros((np.shape(linerelation)[0], 2))
    # format of array: line number, current (A)

    #variable to hold current data
    current = 0
    # variables to hold voltage and conductance
    v = 0
    g = 0
    # for loop to iterate through lines
    for i in range(np.shape(linerelation)[0]):
        # storing the line number
        line_gic[i][0] = linerelation[i][0]
        v = nodalvolts[linerelation[i][1].astype(int)] - nodalvolts[linerelation[i][2].astype(int)]
        g = linerelation[i][4]
        # calculating the current
        # this calculation is similar to the auto series in that it involves the difference between nodal voltages
        # must also account for norton equivalent current calculated from induced voltage
        line_gic[i][1] = linerelation[i][3] + (v * g)
    # returning array
    return line_gic


def effective_auto_gic(transformers, tcarray):
    # this function calculates the effective gic for autotransformers
    # the equation for this follows:
    # Ieff = Iseries + (((Icom/3) - Iseries) * (345/500))
    # array to hold the name of the auto
    # will use this later with the current data from tcarray to calculate the effective gic
    auto_name = []
    for i in range(np.shape(transformers)[0]):
        if transformers[i][1].lower() == 'auto':
            auto_name.append(transformers[i][0])

    # array to hold effective gic info
    effective_gic = np.zeros((len(auto_name), 3), dtype=object)
    # variables to hold current information
    current = 0
    Is = 0
    Ic = 0
    # using a nested for loop to iterate through the names and the curent data
    for i in range(len(auto_name)):
        for j in range(np.shape(tcarray)[0]):
            # gathering info for matching auto series
            if auto_name[i] == tcarray[j][0] and tcarray[j][1].lower() == 'auto, series':
                Is = tcarray[j][2]
            # gathering info for mathing auto common
            if auto_name[i] == tcarray[j][0] and tcarray[j][1].lower() == 'auto, common':
                Ic = tcarray[j][2]
            # calculating current based upon equation
            current = Is + (((Ic / 3) - Is) * (345/500))
            # storing the transformer name
            effective_gic[i][0] = auto_name[i]
            # storing the type as 'Auto, effective'
            effective_gic[i][1] = 'Auto, effective'
            # storing calculated current, rounded to 2 decimal places
            effective_gic[i][2] = round(current, 2)
    # returning array
    return effective_gic





# creating a function to export the calculated data
def export_data_csv(data1, data2, file1, file2):
    # Export the first dataframe to a CSV file
    data1.to_csv(file1, index=False)

    # Export the second dataframe to a CSV file
    data2.to_csv(file2, index=False)


def log_message(message):
    # function to create a log file
    log_file = 'GIC_log.txt'
    with open(log_file, 'a') as file:
        file.write(message + '\n')


E_field = np.array([[[0, 1]], [[1, 0]]])
# this is 3d array corresponds to the two inputted E Fields
# the first E field is 1 V/km in the Northward direction
# the second E field is 1 V/km in the Eastward direction
# created as a 3d array b/c will have to account for time after integration

six_bus_field = np.array([[[10, 0]]])
# this 3d array holds the E field information for the six bus NERC case
# the NERC case only has one field it tests, but making a 3d array to match with functions

# after integration, these arrays will be populated with data from Stephen's subsystem

# using function above to create an array that holds the line data
# this data is from a local csv file, but after integration will be coming from database
# csv file holds same data as that provided in Overbye test case paper
line_array = csv_to_array("/Users/madelineburrows/Desktop/ECEN 403/Line Data.csv")
# format of data: Line number, From Bus, To Bus, Voltage (kV-LL), Length (miles), Resistance (ohm/phase), series cap


# this array has the same format, but is for the smaller test case from NERC
six_bus_line_array = csv_to_array("/Users/madelineburrows/Desktop/ECEN 403/6 Bus Line Data.csv")

# this array is similar to the one above, but this will hold the substation data
substation_array = csv_to_array("/Users/madelineburrows/Desktop/ECEN 403/Substation Data.csv")
# format of data: Substation Name/Number,	Latitude,	Longitude,	Grounding Resistance (Ohm),	Low Bus,	High Bus
# the low bus and high bus parameters were inferred from the diagram of the system provided in the test case paper
# these bus numbers weren't provided in the tables in the paper, but are very necessary for the calculations

# this array holds the info for the substations in the smaller test case
six_bus_sub_array = csv_to_array("/Users/madelineburrows/Desktop/ECEN 403/6 Bus Substation.csv")

# this array holds the transformer data from the smaller test case
six_bus_transformer_array = csv_to_array("/Users/madelineburrows/Desktop/ECEN 403/6 Bus Transformer Data.csv")
# array format: Name, Type, Resistance W1,	Bus No1, Resistance W2,	Bus No2, Blocking Device

# this array holds the same data as the array above, but this one includes a GIC blocking device on transformer 1
# using this array to illustrate that code can account for blocking device
six_bus_trans_array_w_bd = csv_to_array("/Users/madelineburrows/Desktop/ECEN 403/6 Bus Transformer Data w_ GIC BD.csv")

# array to hold 20 bus transformer data
transformer_array = csv_to_array('/Users/madelineburrows/Desktop/ECEN 403/Transformer Data .csv')

line_data = grab_line_cords(line_array, substation_array)
log_message('Locating transmission line end points for 20 bus case')
# array that holds line data for 20 bus case

six_bus_line_data = grab_line_cords(six_bus_line_array, six_bus_sub_array)
log_message('Locating transmission line end points for 6 bus case')
# array that holds line data for 6 bus case
# format: line number, long_from, lat_from, long_to, lat_to


# creating arrays for the 20 bus case and the 6 bus case
length_array = length_calculator(line_data)
log_message('Calculating line lengths for 20 bus case')
six_bus_length = length_calculator(six_bus_line_data)
log_message('Calculating line lengths for 6 bus case')


# creating arrays to hold the calculated induced voltage for the two test cases

six_bus_iv = iv_calculator(six_bus_field, six_bus_length)
log_message('Calculating induced voltages for 6 bus case')
twenty_bus_iv = iv_calculator(E_field, length_array)
log_message('Calculating induced voltages for 20 bus case')


# creating dataframes of both input voltage arrays from 20 bus case
NIV_df = pd.DataFrame(twenty_bus_iv[0], columns=['Line Number', 'Voltage (V)'])
# labeling columns of dataframe
# this is for ease of understanding print statements
NIV_df['Line Number'] = NIV_df['Line Number'].astype(int)
# changing the line number from float to int to get rid of decimal place being shown

# next two lines are doing the same thing as above, just for the other array
EIV_df = pd.DataFrame(twenty_bus_iv[1], columns=['Line Number', 'Voltage (V)'])
EIV_df['Line Number'] = EIV_df['Line Number'].astype(int)


# Result of input voltage submodule validation test: successful
# Values nearly identical to those seen in test case
# Minute differences may be due to rounding
# Greatest difference observed is 10mV, should be negligible

# creating an array to hold the results of the 20 bus case w/ N field and E field
Combined_IV = np.zeros((np.shape(line_data)[0], 3))

for i in range(np.shape(twenty_bus_iv)[1]):
    # looping through and storing the induced voltages from the different fields into single array
    Combined_IV[i][0] = twenty_bus_iv[0][i][0]
    # storing line number
    Combined_IV[i][1] = twenty_bus_iv[0][i][1]
    # storing northward field voltage
    Combined_IV[i][2] = twenty_bus_iv[1][i][1]
    # storing eastward field voltage

# creating dataframe of this array for easier viewing purposes
CIV_df = pd.DataFrame(Combined_IV, columns=['Line Number', 'Northward E Field (V)',
                                            'Eastward E Field (V)'])
CIV_df['Line Number'] = CIV_df['Line Number'].astype(int)

# printing results of induced voltage calculation
print("Calculated Induced Voltages from 20 Bus Test")
print(CIV_df.to_string(index=False))
print("")

# creating arrays that hold the expected values from the twenty bus test case for induced voltage
# this holds the values for the northward e field
expected_20N_iv = np.array([[1, -7.28], [2, 77.31], [3, -45.16], [4, -39.42],
                            [5, -93.47], [6, -93.47], [7, 74.56], [8, 171.60],
                            [9, 97.05], [10, -18.92], [11, -64.08], [12, -64.08],
                            [13, -6.29], [14, -138.64], [15, -178.06]])

# this array holds the expected values from the eastward e field
expected_20E_iv = np.array([[1, 120.60], [2, 93.16], [3, -129.27], [4, 155.56],
                            [5, 131.69], [6, 131.69], [7, 190.99], [8, 169.82],
                            [9, -20.14], [10, 321.26], [11, 191.11], [12, 191.11],
                            [13, 160.17], [14, 1.49], [15, 158.17]])

print("Validation test for Northward E Field Calculation: 20 Bus case")
print("")
# creating variable that will count successes
# 30 successes means all tests passed for 20 bus case
tb_iv_validation_flag = 0
# looping through the array that holds voltages from N field and E field
for i in range(np.shape(Combined_IV)[0]):
    # printing out the expected result with the result my function calculated
    print("Expected: ", expected_20N_iv[i][1].item(), " Got: ", Combined_IV[i][1].item())
    # checking to see if it's within 1% of the expected value
    # using abs to avoid error with negative values
    if (abs(expected_20N_iv[i][1].item()) * 0.99) <= abs(Combined_IV[i][1].item()) <= (abs(expected_20N_iv[i][1].item()) * 1.01):
        print("Test successful. Calculated value within 1% of expected value")
        # incrementing flag if test was a success
        tb_iv_validation_flag += 1
    else:
        print("Fail")

# next few lines of code do the same thing as those above, but this tests the eastward e field values
print("")
print("Validation test for Eastward E Field Calculation: 20 Bus case")
print("")
for i in range(np.shape(Combined_IV)[0]):
    print("Expected: ", expected_20E_iv[i][1].item(), " Got: ", Combined_IV[i][2].item())
    if (abs(expected_20E_iv[i][1].item()) * 0.99) <= abs(Combined_IV[i][2].item()) <= (abs(expected_20E_iv[i][1].item()) * 1.01):
        print("Test successful. Calculated value within 1% of expected value")
        tb_iv_validation_flag += 1
    else:
        print("Fail")

print("")
if tb_iv_validation_flag == 30:
    # if all tests pass, this should be 30 and will print success statement
    print("All tests pass for 20 bus induced voltage case")
    print("")
else:
    # otherwise print how many are failing
    print(30 - tb_iv_validation_flag, " tests failed")

# Create a DataFrame from the 3D array
six_bus_iv_df = pd.DataFrame(six_bus_iv.reshape(-1, six_bus_iv.shape[-1]))

# Set the column names
six_bus_iv_df.columns = ['Line Number', 'Induced Voltage']

# Print the DataFrame
print("Calculated induced Voltages from 6 bus case")
print(six_bus_iv_df.to_string(index=False))
print("")

# similar things going on here as above, validating results from the six bus NERC test case
expected_six_iv = np.array([[1, 931.6], [2, 1555.6]])

print("Validation test for six bus induced voltages:")
sb_iv_flag = 0
for t in range(np.shape(six_bus_iv)[0]):
    for i in range(np.shape(six_bus_iv)[1]):
        print("Expected: ", expected_six_iv[i][1].item(), " Got: ", six_bus_iv[t][i][1].item())
        if (abs(expected_six_iv[i][1].item()) * 0.99) <= abs(six_bus_iv[t][i][1].item()) <= (abs(expected_six_iv[i][1].item()) * 1.01):
            print("Test successful. Calculated value within 1% of expected value")
            sb_iv_flag += 1
        else:
            print("Fail")

print("")
if sb_iv_flag == 2:
    print("All test cases passed for six bus case\n")
else:
    print(2 - sb_iv_flag, " tests failed")


# creating array for the six bus case norton equivalent current
six_bus_ic = equivalent_current(six_bus_iv[0], six_bus_line_array)
log_message('Calculating Norton Equivalent Current for 6 bus case')
# rounding current values to match test case
six_bus_ic[:, 1] = np.round(six_bus_ic[:, 1], 2)

# creating array to hold norton equivalent currents for twenty bus case, Northward field input
twenty_bus_N_ic = equivalent_current(twenty_bus_iv[0], line_array)
log_message('Calculating Norton Equivalent Current for 20 bus case, Northward field')
twenty_bus_N_ic[:, 1] = np.round(twenty_bus_N_ic[:, 1], 2)


# creating dataframe for six bus case norton equivalent currents
six_bus_ic_df = pd.DataFrame(six_bus_ic, columns=['Line Number', 'Equivalent Current', 'From Bus', 'To Bus'])
# formatting dataframe
six_bus_ic_df['Line Number'] = six_bus_ic_df['Line Number'].astype(int)
six_bus_ic_df = six_bus_ic_df[['Line Number', 'Equivalent Current']]
# reformatting to just show the line number and equivalent current

print("Calculated Norton Equivalent Current for 6 bus case:")
print(six_bus_ic_df.to_string(index=False))
print("")

# array to hold expected values from NERC test case
expected_six_bus_current = np.array([[1, -792.83], [2, -1000.39]])

print("Validation test for 6 bus current:")
sb_current_validation = 0
for i in range(np.shape(expected_six_bus_current)[0]):
    print("Expected: ", expected_six_bus_current[i][1].item(), " Got: ", six_bus_ic[i][1].item())
    if (abs(expected_six_bus_current[i][1].item()) * 0.99) <= abs(six_bus_ic[i][1].item()) <= (
            abs(expected_six_bus_current[i][1].item()) * 1.01):
        print("Test successful. Calculated value within 1% of expected value")
        sb_current_validation += 1
    else:
        print("Fail")

if sb_current_validation == 2:
    print("All tests passed for 6 bus calculated current")
else:
    print(2 - sb_current_validation, " tests failed")
print("")

# creating dataframe for twenty bus case, N field input, norton equivalent currents
twenty_bus_N_ic_df = pd.DataFrame(twenty_bus_N_ic, columns=['Line Number', 'Equivalent Current', 'From Bus', 'To Bus'])
twenty_bus_N_ic_df['Line Number'] = twenty_bus_N_ic_df['Line Number'].astype(int)
twenty_bus_N_ic_df = twenty_bus_N_ic_df[['Line Number', 'Equivalent Current']]

print("Calculated currents for 20 bus case, Northward E field")
print(twenty_bus_N_ic_df.to_string(index=False))

# testing to see if lines with series blocking capacitance prevent flow of current
for i in range(np.shape(line_array)[0]):
    if (line_array[i][6] == 1 and twenty_bus_N_ic[i][1] == 0) or (line_array[i][6] == 1 and twenty_bus_N_ic[i][1] == -0):
        print("Test successful: Line", line_array[i][0].astype(int),
              "with series blocking capacitance doesn't allow flow of current\n")


# creating array for six bus case
six_bus_nodes = find_nodes(six_bus_line_array)
log_message('Locating DC model nodes for 6 bus case')

# creating array for 20 bus case
big_case_nodes = find_nodes(line_array)
log_message('Locating DC model nodes for 20 bus case')
# all the correct buses are located, but not accounting for neutral
# must account for neutral at substation 4 and 5 b/c GY-GY and GY-GY-D transformers

nodes_df = pd.DataFrame(six_bus_nodes, columns=['Node Number', 'Bus Number'])
nodes_df['Bus Number'] = nodes_df['Bus Number'].astype(int)
print("Nodes of six bus DC model:")
print(nodes_df.to_string(index=False))
print("")

# expected nodes of DC model from 6 bus case
expected_sixb_nodes = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])

# creating array for 6 bus case current injection vector
six_bus_injected = current_injection_vector_generator(six_bus_nodes, six_bus_ic)
log_message('Generating current injection vector for 6 bus case')

# creating a dataframe from the array above
injected_df = pd.DataFrame(six_bus_injected, columns=['Current Injection Vector'])
print("Calculated Six Bus Injected Current Vector")
print(injected_df.to_string())
print("")

# array comes from test case paper
expected_sixb_injected_vector = np.array([[792.83], [-792.83], [1000.39], [-1000.39]])

print("Expected Six Bus Injected Current Vector")
print(expected_sixb_injected_vector,)

if compare_arrays(expected_sixb_injected_vector, six_bus_injected):
    print("Current Injection Test successful: The arrays are within 1% of each other.\n")
else:
    print("Current Injection Test failed: The arrays are not within 1% of each other.\n")


six_b_conductance, six_b_relation_array, six_b_line_relation = \
    conductance_matrix_node_relation_generator(six_bus_nodes, six_bus_line_array,
                                               six_bus_transformer_array, six_bus_sub_array, six_bus_ic)
log_message('Generating conductance matrix')
log_message('Gathering circuit relationship details for current calculations')
sb_bd_conductance, sb_bd_relation_array, sb_bd_line_relation = \
    conductance_matrix_node_relation_generator(six_bus_nodes, six_bus_line_array,
                                               six_bus_trans_array_w_bd, six_bus_sub_array, six_bus_ic)

print("Calculated Six Bus Conductance Matrix")
print(six_b_conductance, "\n")

# this conductance matrix comes from the 6 bus test case paper
expected_sixb_cond_matrix = np.array([[3.578, -0.851, 0, 0], [-0.851, 19.601, -15, 0],
                                      [0, -15, 15.643, -0.643], [0, 0, -0.643, 3.37]])

print("Expected Conductance Matrix for Six Bus Case:")
print(expected_sixb_cond_matrix, "\n")

if compare_arrays(expected_sixb_cond_matrix, six_b_conductance):
    print("Conduction Matrix Generation Test successful: The arrays are within 1% of each other.\n")
else:
    print("Conduction Matrix Generation Test failed: The arrays are not within 1% of each other.\n")




six_bus_nodal_voltage = node_voltage_calculator(six_b_conductance, six_bus_injected)
log_message('Generating nodal voltage matrix')
sbbd_nv = node_voltage_calculator(sb_bd_conductance, six_bus_injected)

sbnv_df = pd.DataFrame(six_bus_nodal_voltage, columns=['Nodal Voltage'])
print("Calculated Nodal Voltages for Six Bus Case")
print(sbnv_df.to_string(index=False))

print("")
print("Expected Nodal Voltages for Six Bus Case")
expected_sb_nv = np.array([[230.23], [36.34], [87.28], [-280.20]])
print(expected_sb_nv)

if compare_arrays(expected_sb_nv, six_bus_nodal_voltage):
    print("Nodal Voltage Test successful: The arrays are within 1% of each other.\n")
else:
    print("Nodal Voltage Test failed: The arrays are not within 1% of each other.\n")


six_b_t_currents = transformer_current_calculator(six_b_relation_array, six_bus_nodal_voltage)
log_message('Calculating transformer currents')
sbbd_t_currents = transformer_current_calculator(sb_bd_relation_array, sbbd_nv)


tca_df = pd.DataFrame(six_b_t_currents, columns=['Name', 'Type', 'Current (A)'])

sbbd_tc_df = pd.DataFrame(sbbd_t_currents, columns=['Name', 'Type', 'Current (A)'])
print("Calculated Transformer Currents, Six Bus Case")
print(tca_df.to_string(index=False))
print("")

print("Expected Transfomer Currents, Six Bus Case")
expectedsb_t_currents = np.array([['T1', 626.5], ['T3', -762.45], ['T2, series', -762.45], ['T2, common', 135.95]])
expectedsb_t_current_only = np.array([[626.5], [-762.45], [-762.45], [135.95]])
print(expectedsb_t_currents)
print("")

# placing current values only into a new array
# using for loop to fill in array below
# doing this for easier testing w/ validation function
sbtc_c_only = np.zeros((np.shape(six_b_t_currents)[0], 1))
for i in range(np.shape(six_b_t_currents)[0]):
    sbtc_c_only[i][0] = six_b_t_currents[i][2]

if compare_arrays(expectedsb_t_current_only, sbtc_c_only):
    print("Transformer Current Test successful: The arrays are within 1% of each other.\n")
else:
    print("Transformer Current Test failed: The arrays are not within 1% of each other.\n")

print("Calculated Transformer Current when GIC blocking device added to T1")
print(sbbd_tc_df.to_string(index=False))
print("")

if sbbd_t_currents[0][2] == 0:
    print("Test successful. GIC blocking device functioning properly\n")

# calculating line currents for six bus case
six_b_line_currents = line_GIC_calculator(six_b_line_relation, six_bus_nodal_voltage)
log_message('Calculating transmission line GIC')

# creating data frame of line current data
sblc_df = pd.DataFrame(six_b_line_currents, columns=['Line Number', 'GIC (A)'])
sblc_df['Line Number'] = sblc_df['Line Number'].astype(int)

print("Calculated Transmission Line GIC, Six Bus case:")
print(sblc_df.to_string(index=False))
print("")

expected_sb_line_current = np.array([['Line 1', -626.5], ['Line 2', -762.45]])
esblc_only = np.array([[-626.5], [-762.45]])
print("Expected Transmission Line GIC, Six Bus case")
print(expected_sb_line_current)

sblc_only = np.zeros((np.shape(six_b_line_currents)[0], 1))
for i in range(np.shape(six_b_line_currents)[0]):
    sblc_only[i][0] = six_b_line_currents[i][1]


if compare_arrays(esblc_only, sblc_only):
    print("Transmission Line GIC Test successful: The arrays are within 1% of each other.\n")
else:
    print("Transmission Line GIC Test failed: The arrays are not within 1% of each other.\n")

sb_effective_auto = effective_auto_gic(six_bus_transformer_array, six_b_t_currents)
log_message('Calculating effective GIC for autotransformers')

sb_ea_df = pd.DataFrame(sb_effective_auto, columns=['Name', 'Type', 'Current (A)'])

total_sb_tc = pd.concat([tca_df, sb_ea_df], ignore_index=True)

export_data_csv(total_sb_tc, sblc_df, 'TransformerCurrents.csv', 'TransmissionLineGIC.csv')
log_message('Exporting data')
